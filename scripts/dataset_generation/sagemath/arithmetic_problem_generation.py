from typing import Any
import numpy as np
import sage.misc.randstate as randstate
from sage.misc.prandom import randint, choice
from sage.all import prime_range

import click
import warnings

from calt.dataset_generator.sagemath import (
    DatasetGenerator,
    DatasetWriter,
    BaseStatisticsCalculator,
)


class IntFactorProblemGenerator:
    """
    Problem generator for integer factorization problems.

    This generator creates problems in which the problem is an integer n,
    and the solution is a list of prime factors of n in ascending order.
    The problem is generated by multiplying the solution factors.
    All prime factors will be less than or equal to prime_upper_bound.
    """

    def __init__(self, prime_upper_bound: int, min_factors: int, max_factors: int):
        """
        Initialize integer factorization generator.

        Args:
            prime_upper_bound: Upper bound for selecting prime numbers (inclusive)
            min_factors: Minimum number of prime factors
            max_factors: Maximum number of prime factors
        """
        self.prime_upper_bound = prime_upper_bound
        self.min_factors = min_factors
        self.max_factors = max_factors

        self.prime_lst = list(prime_range(2, self.prime_upper_bound + 1))

    def __call__(self, seed: int) -> tuple[int, list[int]]:
        """
        Generate a single sample.

        Each sample consists of:
        - Problem: integer n
        - Solution: list of prime factors in ascending order

        Args:
            seed: Seed for random number generator

        Returns:
            Tuple containing (n, factors)
        """
        # Set random seed for SageMath's random state
        randstate.set_random_seed(seed)

        # Choose number of factors for this sample
        num_factors = randint(self.min_factors, self.max_factors)

        # Generate random prime factors
        factors = [choice(self.prime_lst) for _ in range(num_factors)]

        # Sort factors in ascending order
        factors.sort()

        # Calculate problem integer by multiplying factors
        n = 1
        for p in factors:
            n *= p

        return n, factors


class ArithmeticStatisticsCalculator(BaseStatisticsCalculator):
    """
    Statistics calculator for arithmetic computation problems.

    This calculator computes descriptive statistics for problems involving
    numerical data, such as integer factorization, arithmetic operations,
    or other mathematical computations with arithmetic problems and solutions.

    The calculator handles both single numerical values and lists of
    numerical values, automatically converting them to appropriate formats
    for statistical analysis.
    """

    def __call__(
        self,
        problem: list[Any] | Any,
        solution: list[Any] | Any,
    ) -> dict[str, Any]:
        """
        Calculate statistics for a single generated sample.

        Args:
            problem: Either a list of numerical values or a single numerical value
            solution: Either a list of numerical values or a single numerical value

        Returns:
            Dictionary with keys "problem" and "solution", each mapping to a sub-dictionary
            containing descriptive statistics including:
            - num_values: Number of values in the data
            - max_value: Maximum value in the data
            - min_value: Minimum value in the data
            - mean_value: Arithmetic mean of the values
            - std_value: Standard deviation of the values
            - sum_value: Sum of all values in the data

        Examples:
            >>> calc = ArithmeticStatisticsCalculator()
            >>> stats = calc(problem=42, solution=[2, 3, 7])
            >>> stats['problem']['num_values']
            1
            >>> stats['solution']['num_values']
            3
        """

        return {
            "problem": self.numerical_stats(
                problem if isinstance(problem, list) else [problem]
            ),
            "solution": self.numerical_stats(
                solution if isinstance(solution, list) else [solution]
            ),
        }

    def numerical_stats(self, data: list[Any]) -> dict[str, Any]:
        """
        Calculate statistics for a list of numbers.

        Args:
            data: List of numbers

        Returns:
            Dictionary containing statistical information about the numbers
        """
        if not data:
            raise ValueError("Cannot calculate statistics for empty data list")

        # Convert to float for calculations
        values = [float(n) for n in data]

        stats = {
            "num_values": len(data),
            "max_value": max(values),
            "min_value": min(values),
            "mean_value": float(np.mean(values)),
            "std_value": float(np.std(values)),
            "sum_value": sum(values),
        }

        return stats


@click.command()
@click.option("--save_dir", type=str, default="")
@click.option(
    "--n_jobs", type=int, default=32
)  # set the number of jobs for parallel processing (check your machine's capacity by command `nproc`)
def main(save_dir, n_jobs):
    if save_dir == "":
        # warning
        save_dir = "dataset/integer_factorization_problem"
        warnings.warn(
            f"No save directory provided. Using default save directory {save_dir}."
        )

    # Initialize problem generator
    problem_generator = IntFactorProblemGenerator(
        prime_upper_bound=100,  # All prime factors will be <= prime_upper_bound
        min_factors=2,
        max_factors=10,
    )

    # Initialize statistics calculator
    statistics_calculator = ArithmeticStatisticsCalculator()

    # Initialize dataset generator
    dataset_generator = DatasetGenerator(
        backend="multiprocessing",
        n_jobs=n_jobs,
        verbose=True,
        root_seed=42,
    )

    # Initialize writer
    dataset_writer = DatasetWriter(
        save_dir=save_dir,
        save_text=True,  # whether to save raw text files
        save_json=True,  # whether to save JSON files
    )

    # Generate datasets with batch processing
    dataset_generator.run(
        dataset_sizes={"train": 100000, "test": 1000},
        batch_size=100000,  # set batch size
        problem_generator=problem_generator,
        statistics_calculator=statistics_calculator,
        dataset_writer=dataset_writer,
    )


if __name__ == "__main__":
    main()
