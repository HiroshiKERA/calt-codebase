from typing import List, Tuple, Dict, Any, Union
import numpy as np
import sage.misc.randstate as randstate
from sage.misc.prandom import randint, choice
from sage.all import ZZ, prime_range
from calt.generator.sagemath import (
    DatasetGenerator,
    DatasetWriter,
    BaseStatisticsCalculator,
)


class IntFactorProblemGenerator:
    """
    Problem generator for integer factorization problems.

    This generator creates problems in which the problem is an integer n,
    and the solution is a list of prime factors of n in ascending order.
    The problem is generated by multiplying the solution factors.
    All prime factors will be less than or equal to prime_upper_bound.
    """

    def __init__(self, prime_upper_bound: int, min_factors: int, max_factors: int):
        """
        Initialize integer factorization generator.

        Args:
            prime_upper_bound: Upper bound for selecting prime numbers (inclusive)
            min_factors: Minimum number of prime factors
            max_factors: Maximum number of prime factors
        """
        self.prime_upper_bound = prime_upper_bound
        self.min_factors = min_factors
        self.max_factors = max_factors

        self.prime_lst = list(prime_range(2, self.prime_upper_bound + 1))

    def __call__(self, seed: int) -> Tuple[int, List[int]]:
        """
        Generate a single sample.

        Each sample consists of:
        - Problem: integer n
        - Solution: list of prime factors in ascending order

        Args:
            seed: Seed for random number generator

        Returns:
            Tuple containing (n, factors)
        """
        # Set random seed for SageMath's random state
        randstate.set_random_seed(seed)

        # Choose number of factors for this sample
        num_factors = randint(self.min_factors, self.max_factors)

        # Generate random prime factors
        factors = [choice(self.prime_lst) for _ in range(num_factors)]

        # Sort factors in ascending order
        factors.sort()

        # Calculate problem integer by multiplying factors
        n = ZZ(1)  # Start with SageMath integer
        for p in factors:
            n *= p

        return n, factors


class NumericalStatisticsCalculator(BaseStatisticsCalculator):
    """
    Statistics calculator for numerical computation problems.

    This calculator computes descriptive statistics for problems involving
    numerical data, such as integer factorization, arithmetic operations,
    or other mathematical computations with numerical inputs and outputs.

    The calculator handles both single numerical values and lists of
    numerical values, automatically converting them to appropriate formats
    for statistical analysis.
    """

    def __call__(
        self,
        problem: Union[List[Any], Any],
        solution: Union[List[Any], Any],
    ) -> Dict[str, Any]:
        """
        Calculate statistics for a single generated sample.

        Args:
            problem: Either a list of numerical values or a single numerical value
            solution: Either a list of numerical values or a single numerical value

        Returns:
            Dictionary with keys "input" and "output", each mapping to a sub-dictionary
            containing descriptive statistics including:
            - num_values: Number of values in the data
            - max_value: Maximum value in the data
            - min_value: Minimum value in the data
            - mean_value: Arithmetic mean of the values
            - std_value: Standard deviation of the values
            - sum_value: Sum of all values in the data

        Examples:
            >>> calc = NumericalStatisticsCalculator()
            >>> stats = calc(problem=42, solution=[2, 3, 7])
            >>> stats['input']['num_values']
            1
            >>> stats['output']['num_values']
            3
        """

        if isinstance(problem, list):
            problem_stats = self.numerical_stats(problem)
        else:
            problem_stats = self.numerical_stats([problem])
        if isinstance(solution, list):
            solution_stats = self.numerical_stats(solution)
        else:
            solution_stats = self.numerical_stats([solution])

        return {
            "input": problem_stats,
            "output": solution_stats,
        }

    def numerical_stats(self, numbers: List[Any]) -> Dict[str, Any]:
        """
        Calculate statistics for a list of numbers.

        Args:
            numbers: List of numbers

        Returns:
            Dictionary containing statistical information about the numbers
        """
        # Convert to float for calculations
        values = [float(n) for n in numbers]

        stats = {
            "num_values": len(numbers),
            "max_value": max(values),
            "min_value": min(values),
            "mean_value": float(np.mean(values)),
            "std_value": float(np.std(values)),
            "sum_value": sum(values),
        }

        return stats


def main():
    save_dir = "dataset/sagemath/integer_factorization_problem"

    # Initialize problem generator
    problem_generator = IntFactorProblemGenerator(
        prime_upper_bound=100,  # All prime factors will be <= prime_upper_bound
        min_factors=2,
        max_factors=10,
    )

    # Initialize statistics calculator
    statistics_calculator = NumericalStatisticsCalculator()

    # Initialize dataset generator
    dataset_generator = DatasetGenerator(
        backend="multiprocessing",
        n_jobs=-1,
        verbose=True,
        root_seed=42,
    )

    # Generate training set
    train_samples, train_stats = dataset_generator.run(
        num_samples=100000,
        train=True,
        problem_generator=problem_generator,
        statistics_calculator=statistics_calculator,
    )

    # Generate test set
    test_samples, test_stats = dataset_generator.run(
        num_samples=1000,
        train=False,
        problem_generator=problem_generator,
        statistics_calculator=statistics_calculator,
    )

    # Initialize writer
    dataset_writer = DatasetWriter(save_dir)

    # Save datasets
    dataset_writer.save_dataset(train_samples, train_stats, "train")
    dataset_writer.save_dataset(test_samples, test_stats, "test")


if __name__ == "__main__":
    main()
